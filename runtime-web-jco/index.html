<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Wit wasi runtime jco prepared</title>
    <base href="." />
  </head>
  <body>
    <script>
      let fake = 0;
      let id = 0;

      const symbolDispose = Symbol.dispose || Symbol.for("dispose");

      class InputStream {
        /**
         * @param {InputStreamHandler} handler
         */
        constructor(handler) {
          if (!handler) console.trace("no handler");
          this.id = ++id;
          this.handler = handler;
        }
        read(len) {
          if (this.handler.read) return this.handler.read(len);
          return this.handler.blockingRead.call(this, len);
        }
        blockingRead(len) {
          return this.handler.blockingRead.call(this, len);
        }
        skip(len) {
          if (this.handler.skip) return this.handler.skip.call(this, len);
          if (this.handler.read) {
            const bytes = this.handler.read.call(this, len);
            return BigInt(bytes.byteLength);
          }
          return this.blockingSkip.call(this, len);
        }
        blockingSkip(len) {
          if (this.handler.blockingSkip)
            return this.handler.blockingSkip.call(this, len);
          const bytes = this.handler.blockingRead.call(this, len);
          return BigInt(bytes.byteLength);
        }
        subscribe() {
          console.log(`[streams] Subscribe to input stream ${this.id}`);
        }
        [symbolDispose]() {
          if (this.handler.drop) this.handler.drop.call(this);
        }
      }

      class OutputStream {
        /**
         * @param {OutputStreamHandler} handler
         */
        constructor(handler) {
          if (!handler) console.trace("no handler");
          this.id = ++id;
          this.open = true;
          this.handler = handler;
        }
        checkWrite(len) {
          if (!this.open) return 0n;
          if (this.handler.checkWrite)
            return this.handler.checkWrite.call(this, len);
          return 1_000_000n;
        }
        write(buf) {
          this.handler.write.call(this, buf);
        }
        blockingWriteAndFlush(buf) {
          /// Perform a write of up to 4096 bytes, and then flush the stream. Block
          /// until all of these operations are complete, or an error occurs.
          ///
          /// This is a convenience wrapper around the use of `check-write`,
          /// `subscribe`, `write`, and `flush`, and is implemented with the
          /// following pseudo-code:
          ///
          /// ```text
          /// let pollable = this.subscribe();
          /// while !contents.is_empty() {
          ///     // Wait for the stream to become writable
          ///     poll-one(pollable);
          ///     let Ok(n) = this.check-write(); // eliding error handling
          ///     let len = min(n, contents.len());
          ///     let (chunk, rest) = contents.split_at(len);
          ///     this.write(chunk  );            // eliding error handling
          ///     contents = rest;
          /// }
          /// this.flush();
          /// // Wait for completion of `flush`
          /// poll-one(pollable);
          /// // Check for any errors that arose during `flush`
          /// let _ = this.check-write();         // eliding error handling
          /// ```
          this.handler.write.call(this, buf);
        }
        flush() {
          if (this.handler.flush) this.handler.flush.call(this);
        }
        blockingFlush() {
          this.open = true;
        }
        writeZeroes(len) {
          this.write.call(this, new Uint8Array(Number(len)));
        }
        blockingWriteZeroes(len) {
          this.blockingWrite.call(this, new Uint8Array(Number(len)));
        }
        blockingWriteZeroesAndFlush(len) {
          this.blockingWriteAndFlush.call(this, new Uint8Array(Number(len)));
        }
        splice(src, len) {
          const spliceLen = Math.min(len, this.checkWrite.call(this));
          const bytes = src.read(spliceLen);
          this.write.call(this, bytes);
          return bytes.byteLength;
        }
        blockingSplice(_src, _len) {
          console.log(`[streams] Blocking splice ${this.id}`);
        }
        forward(_src) {
          console.log(`[streams] Forward ${this.id}`);
        }
        subscribe() {
          console.log(`[streams] Subscribe to output stream ${this.id}`);
        }
        [symbolDispose]() {}
      }

      const stdinStream = new InputStream({
        blockingRead(_len) {
          // TODO
        },
        subscribe() {
          // TODO
        },
        [symbolDispose]() {
          // TODO
        },
      });
      let textDecoder = new TextDecoder();
      const stdoutStream = new OutputStream({
        write(contents) {
          console.log(textDecoder.decode(contents));
        },
        blockingFlush() {},
        [symbolDispose]() {},
      });
      const stderrStream = new OutputStream({
        write(contents) {
          console.error(textDecoder.decode(contents));
        },
        blockingFlush() {},
        [symbolDispose]() {},
      });

      class TerminalInput {}
      class TerminalOutput {}

      const terminalStdoutInstance = new TerminalOutput();
      const terminalStderrInstance = new TerminalOutput();
      const terminalStdinInstance = new TerminalInput();

      // import("./out-dir/plugin_wasi.js").then(async ({ instantiate }) => {
      import("./out-dir/wasi_components_guest.js").then(
        async ({ instantiate }) => {
          let wasiImportsFiles = [
            "cli-base",
            "clocks",
            "filesystem",
            "http",
            "io",
            "logging",
            "poll",
            "random",
            "sockets",
          ];
          let wasiImports = {
            "wasi:cli/environment": {
              getEnvironment: () => {
                console.log("GET ENV");
                return [];
              },
            },
            "wasi:cli/exit": {},
            "wasi:cli/stderr": {
              getStderr: () => {
                console.log("GET STDERR");
                // return 2;
                return stderrStream;
              },
            },
            "wasi:cli/stdout": {
              getStdout: () => {
                console.log("GET STDOUT");
                return stdoutStream;
              },
            },
            "wasi:cli/stdin": {
              getStdin: () => {
                console.log("GET STDIN");
                return stdinStream;
              },
            },
            "wasi:cli/terminal-stderr": {
              getTerminalStderr: () => {
                console.log("GET TERMINAL STDERR");
                return terminalStderrInstance;
              },
            },
            "wasi:cli/terminal-stdout": {
              getTerminalStdout: () => {
                console.log("GET TERMINAL STDOUT");
                return terminalStdoutInstance;
              },
            },
            "wasi:cli/terminal-stdin": {
              getTerminalStdin: () => {
                console.log("GET TERMINAL STDIN");
                return terminalStdinInstance;
              },
            },
            "wasi:clocks/monotonic-clock": {
              now: (a, b, c) => {
                //console.log("CALLING MONO NOW WITH:", a, b, c);
                //return BigInt(performance.now() * 1000000);
                console.log("HOW????", fake, performance.now());
                fake = fake + 1000000;
                return fake;
              },
            },
            "wasi:clocks/wall-clock": {
              now: (a, b, c) => {
                console.log("CALLING WALL NOW WITH:", a, b, c);
                let seconds = new Date() / 1000;
                let seconds_whole = Math.floor(seconds);
                let seconds_sub = seconds % 1;
                return {
                  seconds: seconds_whole,
                  nanoseconds: Math.floor(seconds_sub * 1000000000),
                };
              },
            },
            "wasi:filesystem/preopens": {
              getDirectories: () => {
                console.log("GET DIRECTORIES");
                return [];
              },
            },
            "wasi:filesystem/types": {},
            "wasi:io/streams": {
              TerminalInput,
              TerminalOutput,
              InputStream,
              OutputStream,
            },
          };
          for (let wasiImportFile of wasiImportsFiles) {
            wasiImports[`@bytecodealliance/preview2-shim/${wasiImportFile}`] =
              await import(`/src/browser/${wasiImportFile}.js`);
          }
          console.log("WASI IMPORTS:", wasiImports);

          let instance = await instantiate(
            (core, imports) => {
              console.log("Compiling core ...", core, imports);
              // let file = files.find((f) => f[0] === core)[1];
              // console.log("Found file", file);
              // return WebAssembly.compile(file);
              return fetch(`/out-dir/${core}`)
                .then((resp) => resp.arrayBuffer())
                .then((buffer) => {
                  console.log("compile core buffer:", buffer);
                  return WebAssembly.compile(buffer);
                });
            },
            {
              "import-point": {
                default(point) {
                  console.log("IN JCO INSTANTIATED IMPORTS", point);
                  point.x = point.x + 100;
                  return Promise.resolve(point);
                },
              },
              print: {
                default(msg) {
                  console.log("IN JCO INSTANTIATED PRINT:", msg);
                },
              },
              ...wasiImports,
            }
          );
          console.log("INSTANCE:", instance);
          // let { movePoint, sayHello } = instance;

          // sayHello();
          // console.log("MOVE POINT:", movePoint({ x: 50, y: 50 }));
          let { nanosecondsBench, secondsSinceEpoch } = instance;
          console.log("BENCH:", nanosecondsBench());
          console.log("SINCE EPOCHh:", secondsSinceEpoch());
        }
      );

      let module = WebAssembly.compileStreaming(
        fetch("out-dir/no_bindgen_guest.wasm")
      ).then((module) => {
        WebAssembly.instantiate(module, {
          imported_fns: {
            // add_one_i32: (i) => Promise.resolve(i + 2),
            add_one_i32: (i) => i,
            add_one_i64: (i) => i + 1n,
            add_one_f32: (i) => i + 1,
            add_one_f64: (i) => i + 1,
            add_i32_import: (a, b) => a + b,
            increment: () => {},
          },
        }).then((instance) => {
          let result = instance.exports.add_three_i32(5);
          console.log("RESULT IS:", result);
        });
      });
    </script>
  </body>
</html>
