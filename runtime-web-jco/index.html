<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8" />
    <title>Wit wasi runtime jco prepared</title>
    <base href="." />
  </head>
  <body>
    <script>
      let id = 0;

      const symbolDispose = Symbol.dispose || Symbol.for("dispose");

      class InputStream {
        /**
         * @param {InputStreamHandler} handler
         */
        constructor(handler) {
          console.log("*** InputStream::constructor ***");
          if (!handler) console.trace("no handler");
          this.id = ++id;
          this.handler = handler;
        }
        read(len) {
          console.log("*** InputStream::read ***");
          if (this.handler.read) return this.handler.read(len);
          return this.handler.blockingRead.call(this, len);
        }
        blockingRead(len) {
          console.log("*** InputStream::blockingRead ***");
          return this.handler.blockingRead.call(this, len);
        }
        skip(len) {
          console.log("*** InputStream::skip ***");
          if (this.handler.skip) return this.handler.skip.call(this, len);
          if (this.handler.read) {
            const bytes = this.handler.read.call(this, len);
            return BigInt(bytes.byteLength);
          }
          return this.blockingSkip.call(this, len);
        }
        blockingSkip(len) {
          console.log("*** InputStream::blockingSkip ***");
          if (this.handler.blockingSkip)
            return this.handler.blockingSkip.call(this, len);
          const bytes = this.handler.blockingRead.call(this, len);
          return BigInt(bytes.byteLength);
        }
        subscribe() {
          console.log("*** InputStream::subscribe ***");
          console.log(`[streams] Subscribe to input stream ${this.id}`);
        }
        [symbolDispose]() {
          console.log("*** InputStream::dispose ***");
          if (this.handler.drop) this.handler.drop.call(this);
        }
      }

      class OutputStream {
        /**
         * @param {OutputStreamHandler} handler
         */
        constructor(handler) {
          console.log("*** OutputStream::constructor ***");
          if (!handler) console.trace("no handler");
          this.id = ++id;
          this.open = true;
          this.handler = handler;
        }
        checkWrite(len) {
          console.log("*** OutputStream::checkWrite ***");
          if (!this.open) return 0n;
          if (this.handler.checkWrite)
            return this.handler.checkWrite.call(this, len);
          return 1_000_000n;
        }
        write(buf) {
          console.log("*** OutputStream::write ***");
          this.handler.write.call(this, buf);
        }
        blockingWriteAndFlush(buf) {
          console.log("*** OutputStream::blockingWriteAndFlush ***");
          /// Perform a write of up to 4096 bytes, and then flush the stream. Block
          /// until all of these operations are complete, or an error occurs.
          ///
          /// This is a convenience wrapper around the use of `check-write`,
          /// `subscribe`, `write`, and `flush`, and is implemented with the
          /// following pseudo-code:
          ///
          /// ```text
          /// let pollable = this.subscribe();
          /// while !contents.is_empty() {
          ///     // Wait for the stream to become writable
          ///     poll-one(pollable);
          ///     let Ok(n) = this.check-write(); // eliding error handling
          ///     let len = min(n, contents.len());
          ///     let (chunk, rest) = contents.split_at(len);
          ///     this.write(chunk  );            // eliding error handling
          ///     contents = rest;
          /// }
          /// this.flush();
          /// // Wait for completion of `flush`
          /// poll-one(pollable);
          /// // Check for any errors that arose during `flush`
          /// let _ = this.check-write();         // eliding error handling
          /// ```
          this.handler.write.call(this, buf);
        }
        flush() {
          console.log("*** OutputStream::flush ***");
          if (this.handler.flush) this.handler.flush.call(this);
        }
        blockingFlush() {
          console.log("*** OutputStream::blockingFlush ***");
          this.open = true;
        }
        writeZeroes(len) {
          console.log("*** OutputStream::writeZeroes ***");
          this.write.call(this, new Uint8Array(Number(len)));
        }
        blockingWriteZeroes(len) {
          console.log("*** OutputStream::blockingWriteZeroes ***");
          this.blockingWrite.call(this, new Uint8Array(Number(len)));
        }
        blockingWriteZeroesAndFlush(len) {
          console.log("*** OutputStream::blockingWriteZeroesAndFlush ***");
          this.blockingWriteAndFlush.call(this, new Uint8Array(Number(len)));
        }
        splice(src, len) {
          console.log("*** OutputStream::splice ***");
          const spliceLen = Math.min(len, this.checkWrite.call(this));
          const bytes = src.read(spliceLen);
          this.write.call(this, bytes);
          return bytes.byteLength;
        }
        blockingSplice(_src, _len) {
          console.log("*** OutputStream::blockingSplice ***");
          console.log(`[streams] Blocking splice ${this.id}`);
        }
        forward(_src) {
          console.log("*** OutputStream::forward ***");
          console.log(`[streams] Forward ${this.id}`);
        }
        subscribe() {
          console.log("*** OutputStream::subscribe ***");
          console.log(`[streams] Subscribe to output stream ${this.id}`);
        }
        [symbolDispose]() {
          console.log("*** OutputStream::dispose ***");
        }
      }

      let haveRead = false;
      const stdinStream = new InputStream({
        blockingRead(_len) {
          if (haveRead) {
            throw { tag: "closed" };
          }
          haveRead = true;
          let text = new Uint8Array(5);
          text[0] = "H".codePointAt(0);
          text[1] = "e".codePointAt(0);
          text[2] = "l".codePointAt(0);
          text[3] = "l".codePointAt(0);
          text[4] = "o".codePointAt(0);
          return text;
        },
        subscribe() {
          // TODO
        },
        [symbolDispose]() {
          // TODO
        },
      });
      let textDecoder = new TextDecoder();
      const stdoutStream = new OutputStream({
        write(contents) {
          console.log(textDecoder.decode(contents));
        },
        blockingFlush() {},
        [symbolDispose]() {},
      });
      const stderrStream = new OutputStream({
        write(contents) {
          console.error(textDecoder.decode(contents));
        },
        blockingFlush() {},
        [symbolDispose]() {},
      });

      class TerminalInput {}
      class TerminalOutput {}

      const terminalStdoutInstance = new TerminalOutput();
      const terminalStderrInstance = new TerminalOutput();
      const terminalStdinInstance = new TerminalInput();

      // import("./out-dir/plugin_wasi.js").then(async ({ instantiate }) => {
      import("./out-dir/wasi_components_guest.js").then(
        async ({ instantiate }) => {
          let wasiImportsFiles = [
            "cli-base",
            "clocks",
            "filesystem",
            "http",
            "io",
            "logging",
            "poll",
            "random",
            "sockets",
          ];
          let wasiImports = {
            "wasi:cli/environment": {
              getEnvironment: () => {
                console.log("*** GET ENV ***");
                return [];
              },
            },
            "wasi:cli/exit": {},
            "wasi:cli/stdin": {
              getStdin: () => {
                console.log("*** GET STDIN ***");
                return stdinStream;
              },
            },
            "wasi:cli/stdout": {
              getStdout: () => {
                console.log("*** GET STDOUT ***");
                return stdoutStream;
              },
            },
            "wasi:cli/stderr": {
              getStderr: () => {
                console.log("*** GET STDERR ***");
                // return 2;
                return stderrStream;
              },
            },
            "wasi:cli/terminal-stdin": {
              getTerminalStdin: () => {
                console.log("*** GET TERMINAL STDIN ***");
                return terminalStdinInstance;
              },
            },
            "wasi:cli/terminal-stdout": {
              getTerminalStdout: () => {
                console.log("*** GET TERMINAL STDOUT ***");
                return terminalStdoutInstance;
              },
            },
            "wasi:cli/terminal-stderr": {
              getTerminalStderr: () => {
                console.log("*** GET TERMINAL STDERR ***");
                return terminalStderrInstance;
              },
            },
            "wasi:filesystem/preopens": {
              getDirectories: () => {
                console.log("*** GET DIRECTORIES ***");
                return [];
              },
            },
            "wasi:filesystem/types": {},
            "wasi:io/streams": {
              TerminalInput,
              TerminalOutput,
              InputStream,
              OutputStream,
            },
          };
          // for (let wasiImportFile of wasiImportsFiles) {
          //   wasiImports[`@bytecodealliance/preview2-shim/${wasiImportFile}`] =
          //     await import(`/src/browser/${wasiImportFile}.js`);
          // }
          console.log("WASI IMPORTS:", wasiImports);

          let instance = await instantiate(
            (core, imports) => {
              console.log("Compiling core ...", core, imports);
              // let file = files.find((f) => f[0] === core)[1];
              // console.log("Found file", file);
              // return WebAssembly.compile(file);
              return fetch(`/out-dir/${core}`)
                .then((resp) => resp.arrayBuffer())
                .then((buffer) => {
                  console.log("compile core buffer:", buffer);
                  return WebAssembly.compile(buffer);
                });
            },
            {
              ...wasiImports,
            }
          );
          console.log("INSTANCE:", instance);
          // let { movePoint, sayHello } = instance;

          // sayHello();
          // console.log("MOVE POINT:", movePoint({ x: 50, y: 50 }));
          let { readlnFromStdin, writelnToStderr, writelnToStdout } = instance;
          writelnToStdout("=== WRITE TO STDOUT ===");
          writelnToStdout("=== WRITE TO STDOUt AGAIN ===");
          writelnToStderr("=== WRITE TO STDERR ===");
          writelnToStderr("=== WRITE TO STDERR AGAIN ===");
          console.log("Read STD IN:", readlnFromStdin());
          console.log("Read STD IN:", readlnFromStdin());
        }
      );

      // WebAssembly.compileStreaming(fetch("out-dir/no_bindgen_guest.wasm")).then(
      //   (module) => {
      //     WebAssembly.instantiate(module, {
      //       imported_fns: {
      //         // add_one_i32: (i) => Promise.resolve(i + 2),
      //         add_one_i32: (i) => i,
      //         add_one_i64: (i) => i + 1n,
      //         add_one_f32: (i) => i + 1,
      //         add_one_f64: (i) => i + 1,
      //         add_i32_import: (a, b) => a + b,
      //         increment: () => {},
      //       },
      //     }).then((instance) => {
      //       let result = instance.exports.add_three_i32(5);
      //       console.log("RESULT IS:", result);
      //     });
      //   }
      // );
    </script>
  </body>
</html>
